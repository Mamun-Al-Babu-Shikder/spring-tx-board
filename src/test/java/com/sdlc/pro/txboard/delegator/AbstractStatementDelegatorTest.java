package com.sdlc.pro.txboard.delegator;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InOrder;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.sql.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class AbstractStatementDelegatorTest {

    static class TestDelegator extends AbstractStatementDelegator {
        TestDelegator(Statement stmt) {
            super(stmt);
        }
    }

    @Mock
    Statement mockStatement;

    AbstractStatementDelegator delegator;

    @BeforeEach
    void setUp() {
        delegator = new TestDelegator(mockStatement);
    }

    @Test
    void testExecuteDelegation() throws SQLException {
        String sql = "SELECT 1";
        when(mockStatement.execute(sql)).thenReturn(true);
        assertTrue(delegator.execute(sql));
        verify(mockStatement).execute(sql);
    }

    @Test
    void testExecuteWithAutoGeneratedKeyDelegation() throws SQLException {
        String sql = "INSERT INTO test (col) VALUES (1)";
        int genKey = 1;
        when(mockStatement.execute(sql, genKey)).thenReturn(true);
        assertTrue(delegator.execute(sql, genKey));
        verify(mockStatement).execute(sql, genKey);
    }

    @Test
    void testExecuteWithColumnIndexesDelegation() throws SQLException {
        String sql = "INSERT INTO test (col) VALUES (1)";
        int[] colIndexes = {1};
        when(mockStatement.execute(sql, colIndexes)).thenReturn(true);
        assertTrue(delegator.execute(sql, colIndexes));
        verify(mockStatement).execute(sql, colIndexes);
    }

        @Test
    void testExecuteWithColumnNamesDelegation() throws SQLException {
        String sql = "INSERT INTO test (col) VALUES (1)";
        String[] colNames = {"col"};
        when(mockStatement.execute(sql, colNames)).thenReturn(true);
        assertTrue(delegator.execute(sql, colNames));
        verify(mockStatement).execute(sql, colNames);
    }

    @Test
    void testExecuteQueryDelegation() throws SQLException {
        String sql = "SELECT * FROM test";
        ResultSet rs = mock(ResultSet.class);
        when(mockStatement.executeQuery(sql)).thenReturn(rs);
        assertEquals(rs, delegator.executeQuery(sql));
        verify(mockStatement).executeQuery(sql);
    }

    @Test
    void testExecuteUpdateDelegation() throws SQLException {
        String sql = "UPDATE test SET col=1";
        when(mockStatement.executeUpdate(sql)).thenReturn(1);
        assertEquals(1, delegator.executeUpdate(sql));
        verify(mockStatement).executeUpdate(sql);
    }

    @Test
    void testExecuteUpdateWithAutoGeneratedKeyDelegation() throws SQLException {
        String sql = "INSERT INTO test (col) VALUES (1)";
        int genKey = 123;
        when(mockStatement.executeUpdate(sql, genKey)).thenReturn(1);
        assertEquals(1, delegator.executeUpdate(sql, genKey));
        verify(mockStatement).executeUpdate(sql, genKey);
    }

    @Test
    void testExecuteUpdateWithColumnIndexesDelegation() throws SQLException {
        String sql = "INSERT INTO test (col) VALUES (1)";
        int[] colIndex = {1};
        when(mockStatement.executeUpdate(sql, colIndex)).thenReturn(1);
        assertEquals(1, delegator.executeUpdate(sql, colIndex));
        verify(mockStatement).executeUpdate(sql, colIndex);
    }

    @Test
    void testExecuteUpdateWithColumnNamesDelegation() throws SQLException {
        String sql = "INSERT INTO test (col) VALUES (1)";
        String[] colNames = {"col"};
        when(mockStatement.executeUpdate(sql, colNames)).thenReturn(1);
        assertEquals(1, delegator.executeUpdate(sql, colNames));
        verify(mockStatement).executeUpdate(sql, colNames);
    }

    @Test
    void testAddBatchDelegation() throws SQLException {
        String sql = "INSERT INTO test VALUES (1)";
        delegator.addBatch(sql);
        verify(mockStatement).addBatch(sql);
    }

    @Test
    void testCloseDelegation() throws SQLException {
        delegator.close();
        verify(mockStatement).close();
    }

    @Test
    void testGetResultSetDelegation() throws SQLException {
        ResultSet rs = mock(ResultSet.class);
        when(mockStatement.getResultSet()).thenReturn(rs);
        assertEquals(rs, delegator.getResultSet());
        verify(mockStatement).getResultSet();
    }

    @Test
    void testGetUpdateCountDelegation() throws SQLException {
        when(mockStatement.getUpdateCount()).thenReturn(5);
        assertEquals(5, delegator.getUpdateCount());
        verify(mockStatement).getUpdateCount();
    }

    @Test
    void testGetGeneratedKeysDelegation() throws SQLException {
        ResultSet rs = mock(ResultSet.class);
        when(mockStatement.getGeneratedKeys()).thenReturn(rs);
        assertEquals(rs, delegator.getGeneratedKeys());
        verify(mockStatement).getGeneratedKeys();
    }

    @Test
    void testIsClosedDelegation() throws SQLException {
        when(mockStatement.isClosed()).thenReturn(true);
        assertTrue(delegator.isClosed());
        verify(mockStatement).isClosed();
    }

    @Test
    void testSetMaxRowsDelegation() throws SQLException {
        delegator.setMaxRows(10);
        verify(mockStatement).setMaxRows(10);
    }

    @Test
    void testSetQueryTimeoutDelegation() throws SQLException {
        delegator.setQueryTimeout(30);
        verify(mockStatement).setQueryTimeout(30);
    }

    @Test
    void testClearBatchDelegation() throws SQLException {
        delegator.clearBatch();
        verify(mockStatement).clearBatch();
    }

    @Test
    void testClearWarningsDelegation() throws SQLException {
        delegator.clearWarnings();
        verify(mockStatement).clearWarnings();
    }

    @Test
    void testCancelDelegation() throws SQLException {
        delegator.cancel();
        verify(mockStatement).cancel();
    }

    @Test
    void testGetWarningsDelegation() throws SQLException {
        SQLWarning warning = new SQLWarning("test");
        when(mockStatement.getWarnings()).thenReturn(warning);
        assertEquals(warning, delegator.getWarnings());
        verify(mockStatement).getWarnings();
    }

    @Test
    void testGetMoreResultsDelegation() throws SQLException {
        when(mockStatement.getMoreResults()).thenReturn(true);
        assertTrue(delegator.getMoreResults());
        verify(mockStatement).getMoreResults();
    }

    @Test
    void testGetMoreResultsWithParamDelegation() throws SQLException {
        when(mockStatement.getMoreResults(Statement.CLOSE_ALL_RESULTS)).thenReturn(false);
        assertFalse(delegator.getMoreResults(Statement.CLOSE_ALL_RESULTS));
        verify(mockStatement).getMoreResults(Statement.CLOSE_ALL_RESULTS);
    }

    @Test
    void testExecuteBatchDelegation() throws SQLException {
        int[] result = {1, 2, 3};
        when(mockStatement.executeBatch()).thenReturn(result);
        assertArrayEquals(result, delegator.executeBatch());
        verify(mockStatement).executeBatch();
    }

    @Test
    void testSetFetchDirectionDelegation() throws SQLException {
        delegator.setFetchDirection(ResultSet.FETCH_FORWARD);
        verify(mockStatement).setFetchDirection(ResultSet.FETCH_FORWARD);
    }

    @Test
    void testSetFetchSizeDelegation() throws SQLException {
        delegator.setFetchSize(100);
        verify(mockStatement).setFetchSize(100);
    }

    @Test
    void testSetEscapeProcessingDelegation() throws SQLException {
        delegator.setEscapeProcessing(true);
        verify(mockStatement).setEscapeProcessing(true);
    }

    @Test
    void testSetCursorNameDelegation() throws SQLException {
        delegator.setCursorName("cursor1");
        verify(mockStatement).setCursorName("cursor1");
    }

    @Test
    void testGetMaxRowsDelegation() throws SQLException {
        when(mockStatement.getMaxRows()).thenReturn(50);
        assertEquals(50, delegator.getMaxRows());
        verify(mockStatement).getMaxRows();
    }

    @Test
    void testGetQueryTimeoutDelegation() throws SQLException {
        when(mockStatement.getQueryTimeout()).thenReturn(60);
        assertEquals(60, delegator.getQueryTimeout());
        verify(mockStatement).getQueryTimeout();
    }

    @Test
    void testGetFetchDirectionDelegation() throws SQLException {
        when(mockStatement.getFetchDirection()).thenReturn(ResultSet.FETCH_REVERSE);
        assertEquals(ResultSet.FETCH_REVERSE, delegator.getFetchDirection());
        verify(mockStatement).getFetchDirection();
    }

    @Test
    void testGetFetchSizeDelegation() throws SQLException {
        when(mockStatement.getFetchSize()).thenReturn(200);
        assertEquals(200, delegator.getFetchSize());
        verify(mockStatement).getFetchSize();
    }

    @Test
    void testGetResultSetConcurrencyDelegation() throws SQLException {
        when(mockStatement.getResultSetConcurrency()).thenReturn(ResultSet.CONCUR_UPDATABLE);
        assertEquals(ResultSet.CONCUR_UPDATABLE, delegator.getResultSetConcurrency());
        verify(mockStatement).getResultSetConcurrency();
    }

    @Test
    void testGetResultSetTypeDelegation() throws SQLException {
        when(mockStatement.getResultSetType()).thenReturn(ResultSet.TYPE_SCROLL_INSENSITIVE);
        assertEquals(ResultSet.TYPE_SCROLL_INSENSITIVE, delegator.getResultSetType());
        verify(mockStatement).getResultSetType();
    }

    @Test
    void testGetResultSetHoldabilityDelegation() throws SQLException {
        when(mockStatement.getResultSetHoldability()).thenReturn(ResultSet.HOLD_CURSORS_OVER_COMMIT);
        assertEquals(ResultSet.HOLD_CURSORS_OVER_COMMIT, delegator.getResultSetHoldability());
        verify(mockStatement).getResultSetHoldability();
    }

    @Test
    void testIsPoolableDelegation() throws SQLException {
        when(mockStatement.isPoolable()).thenReturn(true);
        assertTrue(delegator.isPoolable());
        verify(mockStatement).isPoolable();
    }

    @Test
    void testSetPoolableDelegation() throws SQLException {
        delegator.setPoolable(true);
        verify(mockStatement).setPoolable(true);
    }

    @Test
    void testEncloseInOrder() throws SQLException {
        delegator.clearBatch();
        delegator.close();
        InOrder inOrder = inOrder(mockStatement);
        inOrder.verify(mockStatement).clearBatch();
        inOrder.verify(mockStatement).close();
    }

    @Test
    void testGetMaxFieldSizeDelegation() throws SQLException {
        when(mockStatement.getMaxFieldSize()).thenReturn(255);
        assertEquals(255, delegator.getMaxFieldSize());
        verify(mockStatement).getMaxFieldSize();
    }

    @Test
    void testSetMaxFieldSizeDelegation() throws SQLException {
        delegator.setMaxFieldSize(255);
        verify(mockStatement).setMaxFieldSize(255);
    }

    @Test
    void testGetConnectionDelegation() throws SQLException {
        Connection mockConnection = mock(Connection.class);
        when(mockStatement.getConnection()).thenReturn(mockConnection);
        assertEquals(mockConnection, delegator.getConnection());
        verify(mockStatement).getConnection();
    }

    @Test
    void testCloseOnCompletionDelegation() throws SQLException {
        delegator.closeOnCompletion();
        verify(mockStatement).closeOnCompletion();
    }

    @Test
    void testIsCloseOnCompletionDelegation() throws SQLException {
        when(mockStatement.isCloseOnCompletion()).thenReturn(true);
        assertTrue(delegator.isCloseOnCompletion());
        verify(mockStatement).isCloseOnCompletion();
    }

    @Test
    void testGetLargeUpdateCountDelegation() throws SQLException {
        when(mockStatement.getLargeUpdateCount()).thenReturn(1000L);
        assertEquals(1000L, delegator.getLargeUpdateCount());
        verify(mockStatement).getLargeUpdateCount();
    }

    @Test
    void testSetLargeMaxRows() throws SQLException {
        delegator.setLargeMaxRows(1000L);
        verify(mockStatement).setLargeMaxRows(1000L);
    }

    @Test
    void testGetLargeMaxRowsDelegation() throws SQLException {
        when(mockStatement.getLargeMaxRows()).thenReturn(1000L);
        assertEquals(1000L, delegator.getLargeMaxRows());
        verify(mockStatement).getLargeMaxRows();
    }

    @Test
    void testExecuteLargeBatchDelegation() throws SQLException {
        long[] largeBatch = {1L, 2L, 3L};
        when(mockStatement.executeLargeBatch()).thenReturn(largeBatch);
        assertArrayEquals(largeBatch, delegator.executeLargeBatch());
        verify(mockStatement).executeLargeBatch();
    }

    @Test
    void testExecuteLargeUpdateDelegation() throws SQLException {
        String sql = "UPDATE test SET col=1";
        when(mockStatement.executeLargeUpdate(sql)).thenReturn(1L);
        assertEquals(1L, delegator.executeLargeUpdate(sql));
        verify(mockStatement).executeLargeUpdate(sql);
    }

    @Test
    void testExecuteLargeUpdateWithAutoGeneratedKeysDelegation() throws SQLException {
        String sql = "UPDATE test SET col=1";
        int genKeys = 1;
        when(mockStatement.executeLargeUpdate(sql, genKeys)).thenReturn(1L);
        assertEquals(1L, delegator.executeLargeUpdate(sql, genKeys));
        verify(mockStatement).executeLargeUpdate(sql, genKeys);
    }

    @Test
    void testExecuteLargeUpdateWithColumnIndexesDelegation() throws SQLException {
        String sql = "UPDATE test SET col=1";
        int[] columnIndexes = {1};
        when(mockStatement.executeLargeUpdate(sql, columnIndexes)).thenReturn(1L);
        assertEquals(1L, delegator.executeLargeUpdate(sql, columnIndexes));
        verify(mockStatement).executeLargeUpdate(sql, columnIndexes);
    }

    @Test
    void testExecuteLargeUpdateWithColumnNamesDelegation() throws SQLException {
        String sql = "UPDATE test SET col=1";
        String[] columnNames = {"col"};
        when(mockStatement.executeLargeUpdate(sql, columnNames)).thenReturn(1L);
        assertEquals(1L, delegator.executeLargeUpdate(sql, columnNames));
        verify(mockStatement).executeLargeUpdate(sql, columnNames);
    }

    @Test
    void testUnwrapDelegation() throws SQLException {
        String mockString = "unwrapped";
        when(mockStatement.unwrap(String.class)).thenReturn(mockString);
        assertEquals(mockString, delegator.unwrap(String.class));
        verify(mockStatement).unwrap(String.class);
    }

    @Test
    void testIsWrapperForDelegation() throws SQLException {
        when(mockStatement.isWrapperFor(String.class)).thenReturn(true);
        assertTrue(delegator.isWrapperFor(String.class));
        verify(mockStatement).isWrapperFor(String.class);
    }
}
