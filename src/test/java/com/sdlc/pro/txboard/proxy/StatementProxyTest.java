package com.sdlc.pro.txboard.proxy;

import com.sdlc.pro.txboard.listener.TransactionPhaseListener;
import com.sdlc.pro.txboard.listener.TransactionPhaseListenerImpl;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class StatementProxyTest {
    private Statement statement;
    private TransactionPhaseListener transactionPhaseListener;
    private StatementProxy statementProxy;

    @BeforeEach
    void setup() throws SQLException {
        statement = mock(Statement.class);
        transactionPhaseListener = mock(TransactionPhaseListenerImpl.class);
        statementProxy = new StatementProxy(statement, transactionPhaseListener);
    }

    @Test
    void testExecuteQuery() throws SQLException {
        // Given
        String sql = "SELECT * FROM users";
        ResultSet mockResultSet = mock(ResultSet.class);

        when(statement.executeQuery(sql)).thenReturn(mockResultSet);

        // When
        ResultSet result = statementProxy.executeQuery(sql);

        // Then
        verify(transactionPhaseListener).executedQuery(sql);
        verify(statement).executeQuery(sql);
        assertSame(mockResultSet, result);
    }

    @Test
    void shouldCreateStatementProxyWithTransactionPhaseListener() {
        assertThat(statementProxy).isNotNull();
        assertThat(statementProxy).extracting("transactionPhaseListener").isEqualTo(transactionPhaseListener);
    }

    @Test
    void shouldDelegateToActualExecuteQueryMethod() throws SQLException {
        String SQL = "select * from product";
        ResultSet mockResultSet = mock(ResultSet.class);

        when(statement.executeQuery(SQL)).thenReturn(mockResultSet);

        ResultSet result = statementProxy.executeQuery(SQL);

        verify(statement, times(1)).executeQuery(SQL);
        assertThat(result).isEqualTo(mockResultSet);
    }

    @Test
    void shouldNotifyTheSqlToListenerAndInvokeActualExecuteUpdateMethod() throws SQLException {
        String SQL = "update product set price = 100 where id = 1";
        int expectedRows = 1;

        when(statement.executeUpdate(SQL)).thenReturn(expectedRows);

        int result = statementProxy.executeUpdate(SQL);

        verify(transactionPhaseListener, times(1)).executedQuery(SQL);
        verify(statement, times(1)).executeUpdate(SQL);
        assertThat(result).isEqualTo(expectedRows);
    }

    @Test
    void shouldNotifyTheSqlToListenerAndInvokeActualExecuteMethod() throws SQLException {
        String SQL = "create table test (id int)";
        boolean expectedResult = true;

        when(statement.execute(SQL)).thenReturn(expectedResult);

        boolean result = statementProxy.execute(SQL);

        verify(transactionPhaseListener, times(1)).executedQuery(SQL);
        verify(statement, times(1)).execute(SQL);
        assertThat(result).isEqualTo(expectedResult);
    }

    @Test
    void shouldNotifyTheSqlToListenerAndInvokeActualExecuteUpdate2ParamMethod() throws SQLException {
        String SQL = "insert into users (name) values (?)";
        int autoGeneratedKeys = Statement.RETURN_GENERATED_KEYS;
        int expectedRows = 1;

        when(statement.executeUpdate(SQL, autoGeneratedKeys)).thenReturn(expectedRows);

        int result = statementProxy.executeUpdate(SQL, autoGeneratedKeys);

        verify(transactionPhaseListener, times(1)).executedQuery(SQL);
        verify(statement, times(1)).executeUpdate(SQL, autoGeneratedKeys);
        assertThat(result).isEqualTo(expectedRows);
    }

    @Test
    void shouldNotifyTheSqlToListenerAndInvokeActualExecuteUpdateWithColumnIndexesMethod() throws SQLException {
        String SQL = "insert into users (name) values (?)";
        int[] columnIndexes = {1};
        int expectedRows = 1;

        when(statement.executeUpdate(SQL, columnIndexes)).thenReturn(expectedRows);

        int result = statementProxy.executeUpdate(SQL, columnIndexes);

        verify(transactionPhaseListener, times(1)).executedQuery(SQL);
        verify(statement, times(1)).executeUpdate(SQL, columnIndexes);
        assertThat(result).isEqualTo(expectedRows);
    }

    @Test
    void shouldNotifyTheSqlToListenerAndInvokeActualExecuteUpdateWithColumnNamesMethod() throws SQLException {
        String SQL = "insert into users (name) values (?)";
        String[] columnNames = {"id"};
        int expectedRows = 1;

        when(statement.executeUpdate(SQL, columnNames)).thenReturn(expectedRows);

        int result = statementProxy.executeUpdate(SQL, columnNames);

        verify(transactionPhaseListener, times(1)).executedQuery(SQL);
        verify(statement, times(1)).executeUpdate(SQL, columnNames);
        assertThat(result).isEqualTo(expectedRows);
    }

    @Test
    void shouldNotifyTheSqlToListenerAndInvokeActualExecute2ParamMethod() throws SQLException {
        String SQL = "insert into users (name) values (?)";
        int autoGeneratedKeys = Statement.RETURN_GENERATED_KEYS;
        boolean expectedResult = true;

        when(statement.execute(SQL, autoGeneratedKeys)).thenReturn(expectedResult);

        boolean result = statementProxy.execute(SQL, autoGeneratedKeys);

        verify(transactionPhaseListener, times(1)).executedQuery(SQL);
        verify(statement, times(1)).execute(SQL, autoGeneratedKeys);
        assertThat(result).isEqualTo(expectedResult);
    }
    @Test
    void shouldNotifyTheSqlToListenerAndInvokeActualExecuteWithColumnIndexesMethod() throws SQLException {
        String SQL = "insert into users (name) values (?)";
        int[] columnIndexes = {1};
        boolean expectedResult = true;

        when(statement.execute(SQL, columnIndexes)).thenReturn(expectedResult);

        boolean result = statementProxy.execute(SQL, columnIndexes);

        verify(transactionPhaseListener, times(1)).executedQuery(SQL);
        verify(statement, times(1)).execute(SQL, columnIndexes);
        assertThat(result).isEqualTo(expectedResult);
    }

    @Test
    void shouldNotifyTheSqlToListenerAndInvokeActualExecuteWithColumnNamesMethod() throws SQLException {
        String SQL = "insert into users (name) values (?)";
        String[] columnNames = {"id"};
        boolean expectedResult = true;

        when(statement.execute(SQL, columnNames)).thenReturn(expectedResult);

        boolean result = statementProxy.execute(SQL, columnNames);

        verify(transactionPhaseListener, times(1)).executedQuery(SQL);
        verify(statement, times(1)).execute(SQL, columnNames);
        assertThat(result).isEqualTo(expectedResult);
    }

    @Test
    void shouldDelegateToActualGetConnectionMethod() throws SQLException {
        Connection mockConnection = mock(Connection.class);

        when(statement.getConnection()).thenReturn(mockConnection);

        Connection result = statementProxy.getConnection();

        verify(statement, times(1)).getConnection();
        assertThat(result).isEqualTo(mockConnection);
    }

    @Test
    void shouldDelegateToActualGetResultSetMethod() throws SQLException {
        ResultSet mockResultSet = mock(ResultSet.class);

        when(statement.getResultSet()).thenReturn(mockResultSet);

        ResultSet result = statementProxy.getResultSet();

        verify(statement, times(1)).getResultSet();
        assertThat(result).isEqualTo(mockResultSet);
    }
    @Test
    void shouldCloseActualStatement() throws SQLException {
        statementProxy.close();
        verify(statement, times(1)).close();
    }

    @Test
    void shouldDelegateToActualGetMaxRowsMethod() throws SQLException {
        int expectedMaxRows = 100;

        when(statement.getMaxRows()).thenReturn(expectedMaxRows);

        int result = statementProxy.getMaxRows();

        verify(statement, times(1)).getMaxRows();
        assertThat(result).isEqualTo(expectedMaxRows);
    }

    @Test
    void shouldDelegateToActualSetMaxRowsMethod() throws SQLException {
        int maxRows = 100;

        statementProxy.setMaxRows(maxRows);

        verify(statement, times(1)).setMaxRows(maxRows);
    }

    @Test
    void shouldDelegateToActualIsClosedMethod() throws SQLException {
        when(statement.isClosed()).thenReturn(true);

        boolean result = statementProxy.isClosed();

        verify(statement, times(1)).isClosed();
        assertThat(result).isTrue();
    }

    @Test
    void shouldNotifyListenerWhenExceptionOccurs() throws SQLException {
        String SQL = "select * from invalid_table";
        SQLException expectedException = new SQLException("Table not found");

        when(statement.executeQuery(SQL)).thenThrow(expectedException);

        SQLException thrownException = org.junit.jupiter.api.Assertions.assertThrows(
                SQLException.class,
                () -> statementProxy.executeQuery(SQL)
        );

        verify(transactionPhaseListener, times(1)).executedQuery(SQL);
        verify(statement, times(1)).executeQuery(SQL);
        assertThat((Iterable<? extends Throwable>) thrownException).isEqualTo(expectedException);
    }
}